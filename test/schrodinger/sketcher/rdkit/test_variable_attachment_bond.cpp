
#define BOOST_TEST_MODULE variable_attachment_bond

#include "../test_common.h"
#include "schrodinger/rdkit_extensions/convert.h"
#include "schrodinger/rdkit_extensions/variable_attachment_bond.h"
#include "schrodinger/sketcher/rdkit/variable_attachment_bond.h"

namespace schrodinger
{
namespace sketcher
{

/**
 * A molecule with a variable attachment bond that's too short and far away from
 * the variable attachment atoms
 */
const std::string DISTORTED_VAR_ATTACH_MOL = R"(
     RDKit          2D

  0  0  0  0  0  0  0  0  0  0999 V3000
M  V30 BEGIN CTAB
M  V30 COUNTS 8 7 0 0 0
M  V30 BEGIN ATOM
M  V30 1 C 1.121212 -2.000000 0.000000 0
M  V30 2 C 0.371212 -3.299038 0.000000 0
M  V30 3 C -1.128788 -3.299038 0.000000 0
M  V30 4 C -1.878788 -2.000000 0.000000 0
M  V30 5 C -1.128788 -0.700962 0.000000 0
M  V30 6 C 0.371212 -0.700962 0.000000 0
M  V30 7 * 0.090909 2.636364 0.000000 0
M  V30 8 C 1.590909 2.636364 0.000000 0
M  V30 END ATOM
M  V30 BEGIN BOND
M  V30 1 1 1 2
M  V30 2 1 2 3
M  V30 3 1 3 4
M  V30 4 1 4 5
M  V30 5 1 5 6
M  V30 6 1 6 1
M  V30 7 1 7 8 ENDPTS=(3 2 3 4) ATTACH=ANY
M  V30 END BOND
M  V30 END CTAB
M  END
$$$$

)";

/**
 * A molecule with a variable attachment bond where the variable attachment
 * atoms don't have any bonds.  This is invalid, as the variable attachment
 * atoms are supposed to be part of the same connected component.
 */
const std::string INVALID_VAR_ATTACH_MOL = R"(
     RDKit          2D

  0  0  0  0  0  0  0  0  0  0999 V3000
M  V30 BEGIN CTAB
M  V30 COUNTS 8 4 0 0 0
M  V30 BEGIN ATOM
M  V30 1 C -2.448535 -0.914286 0.000000 0
M  V30 2 C -1.211356 -0.200000 0.000000 0
M  V30 3 C -1.211356 1.228571 0.000000 0
M  V30 4 C -2.448535 1.942857 0.000000 0
M  V30 5 C -3.685714 1.228571 0.000000 0
M  V30 6 C -3.685714 -0.200000 0.000000 0
M  V30 7 C 0.217215 0.514286 0.000000 0
M  V30 8 * -0.497070 0.514286 0.000000 0
M  V30 END ATOM
M  V30 BEGIN BOND
M  V30 1 1 4 5
M  V30 2 1 5 6
M  V30 3 1 6 1
M  V30 4 1 8 7 ENDPTS=(2 2 3) ATTACH=ANY
M  V30 END BOND
M  V30 END CTAB
M  END
$$$$

)";

/**
 * Make sure that fix_variable_attachment_bond_coordinates() can correct
 * distorted coordinates similar to those generated by compute2DCoords()
 */
BOOST_AUTO_TEST_CASE(test_fix_variable_attachment_bond_coordinates,
                     *boost::unit_test::tolerance(0.01))
{
    auto mol = rdkit_extensions::to_rdkit(DISTORTED_VAR_ATTACH_MOL);
    auto& conf = mol->getConformer();
    auto* var_attach_bond = mol->getBondWithIdx(6);
    BOOST_TEST(rdkit_extensions::is_variable_attachment_bond(var_attach_bond));
    auto bond_length = (conf.getAtomPos(6) - conf.getAtomPos(7)).length();
    BOOST_TEST(bond_length == 1.5);
    auto dummy_to_ring_dist =
        (conf.getAtomPos(6) - conf.getAtomPos(2)).length();
    BOOST_TEST(dummy_to_ring_dist > 5);

    fix_variable_attachment_bond_coordinates(*mol);
    bond_length = (conf.getAtomPos(6) - conf.getAtomPos(7)).length();
    BOOST_TEST(bond_length == 2.25);
    dummy_to_ring_dist = (conf.getAtomPos(6) - conf.getAtomPos(2)).length();
    BOOST_TEST(dummy_to_ring_dist < 1.5);
}

/**
 * Make sure that fix_variable_attachment_bond_coordinates() doesn't crash when
 * passed a molecule with an invalid variable attachment bond.  The variable
 * attachment atomso don't have any bonds, so there are no potential crossing
 * bonds.
 */
BOOST_AUTO_TEST_CASE(test_fix_variable_attachment_bond_coordinates_invalid_bond)
{
    auto mol = rdkit_extensions::to_rdkit(INVALID_VAR_ATTACH_MOL);
    // we don't care about the output structure, we just want to make sure that
    // this call doesn't crash
    fix_variable_attachment_bond_coordinates(*mol);
}

} // namespace sketcher
} // namespace schrodinger